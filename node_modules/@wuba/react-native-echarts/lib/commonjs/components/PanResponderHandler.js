"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanResponderHandler = PanResponderHandler;
exports.calcCenter = calcCenter;
exports.calcDistance = calcDistance;
exports.usePanResponder = usePanResponder;
var _reactNative = require("react-native");
var _react = _interopRequireWildcard(require("react"));
var _styles = require("./styles");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function calcDistance(x0, y0, x1, y1) {
  const dx = x0 - x1;
  const dy = y0 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
function calMiddle(p0, p1) {
  return (p0 + p1) / 2;
}
function calcCenter(x0, y0, x1, y1) {
  return {
    x: calMiddle(x1, x0),
    y: calMiddle(y1, y0)
  };
}
function PanResponderHandler({
  dispatchEvents
}) {
  const [panResponder] = usePanResponder(dispatchEvents);
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({
    testID: "pan-responder-handler"
  }, panResponder.panHandlers, {
    style: _styles.styles.GestureView
  }));
}
function usePanResponder(dispatchEvents) {
  const panResponder = (0, _react.useMemo)(() => {
    let zooming = false;
    let moving = false;
    let pan = {
      initialX: 0,
      initialY: 0,
      prevDistance: 0
    };
    return _reactNative.PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onStartShouldSetPanResponderCapture: () => true,
      onMoveShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponderCapture: () => true,
      onPanResponderGrant: ({
        nativeEvent
      }) => {
        dispatchEvents(['mousedown', 'mousemove'], nativeEvent);
      },
      onPanResponderMove: ({
        nativeEvent
      }) => {
        const touches = nativeEvent.touches;
        const length = touches.length;
        if (length === 1) {
          if (!moving || zooming) {
            moving = true;
            zooming = false;
          } else {
            dispatchEvents(['mousemove'], nativeEvent);
          }
        } else if (length === 2) {
          const [{
            locationX: x0,
            locationY: y0
          }, {
            locationX: x1,
            locationY: y1
          }] = touches;
          const distance = calcDistance(x0, y0, x1, y1);
          const {
            x,
            y
          } = calcCenter(x0, y0, x1, y1);
          if (!zooming) {
            pan = {
              initialX: x,
              initialY: y,
              prevDistance: distance
            };
            zooming = true;
          } else {
            const {
              initialX,
              initialY,
              prevDistance
            } = pan;
            const delta = distance - prevDistance;
            pan.prevDistance = distance;
            dispatchEvents(['mousewheel'], nativeEvent, {
              zrX: initialX,
              zrY: initialY,
              zrDelta: delta / 120
            });
          }
        }
      },
      onPanResponderTerminationRequest: () => true,
      onPanResponderRelease: ({
        nativeEvent
      }) => {
        if (!zooming) {
          dispatchEvents(['mouseup', 'click'], nativeEvent);
        }
        moving = false;
        zooming = false;
      },
      onPanResponderTerminate: () => {},
      onShouldBlockNativeResponder: () => {
        return false;
      }
    });
  }, [dispatchEvents]);
  return [panResponder];
}
//# sourceMappingURL=PanResponderHandler.js.map